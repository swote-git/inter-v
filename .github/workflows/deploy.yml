name: Deploy InterV Application

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'

env:
  AWS_REGION: ap-northeast-2
  APPLICATION_NAME: interv

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    if: contains(github.event.head_commit.message, '[deploy-infra]') || contains(github.event.head_commit.modified, 'infrastructure/')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ~1.6.0
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Initialize Terraform
      run: |
        cd infrastructure/
        echo "ğŸ—ï¸ Initializing Terraform..."
        terraform init
    
    - name: Smart Resource Discovery and Import
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_key_pair_name: ${{ secrets.EC2_KEY_PAIR_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_app_name: ${{ env.APPLICATION_NAME }}
        TF_VAR_domain_name: "interv.swote.dev"
      run: |
        cd infrastructure/
        
        echo "ğŸ” Discovering existing AWS resources..."
        
        # ë¦¬ì†ŒìŠ¤ ê²€ìƒ‰ ë° ìë™ import í•¨ìˆ˜
        auto_import_resource() {
            local resource_type="$1"
            local resource_name="$2"
            local aws_resource_id="$3"
            local check_command="$4"
            
            echo "  ğŸ” Checking $resource_type: $resource_name"
            
            if eval "$check_command" >/dev/null 2>&1; then
                echo "    âœ… Found existing resource: $aws_resource_id"
                if terraform import "$resource_name" "$aws_resource_id" 2>/dev/null; then
                    echo "    ğŸ“¥ Successfully imported: $resource_name"
                else
                    echo "    âš ï¸ Import failed or already imported: $resource_name"
                fi
            else
                echo "    âŒ Resource not found: $resource_type"
            fi
        }
        
        echo ""
        echo "ğŸ“¥ Starting automatic resource import..."
        echo ""
        
        # 1. VPC ê´€ë ¨ ë¦¬ì†ŒìŠ¤ (ìˆë‹¤ë©´)
        echo "ğŸŒ VPC Resources:"
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=interv-vpc" --query 'Vpcs[0].VpcId' --output text 2>/dev/null || echo "None")
        if [ "$VPC_ID" != "None" ] && [ "$VPC_ID" != "null" ]; then
            auto_import_resource "VPC" "aws_vpc.main" "$VPC_ID" "aws ec2 describe-vpcs --vpc-ids $VPC_ID"
        fi
        
        # 2. S3 Bucket
        echo "ğŸª£ S3 Resources:"
        S3_BUCKET=$(aws s3api list-buckets --query "Buckets[?starts_with(Name, 'interv-storage-')].Name" --output text 2>/dev/null || echo "None")
        if [ "$S3_BUCKET" != "None" ] && [ "$S3_BUCKET" != "null" ]; then
            auto_import_resource "S3 Bucket" "aws_s3_bucket.app_storage" "$S3_BUCKET" "aws s3api head-bucket --bucket $S3_BUCKET"
            auto_import_resource "S3 Versioning" "aws_s3_bucket_versioning.app_storage" "$S3_BUCKET" "aws s3api get-bucket-versioning --bucket $S3_BUCKET"
        fi
        
        # 3. IAM Resources
        echo "ğŸ‘¤ IAM Resources:"
        auto_import_resource "IAM Role" "aws_iam_role.ec2_role" "interv-ec2-role" "aws iam get-role --role-name interv-ec2-role"
        auto_import_resource "IAM Role Policy" "aws_iam_role_policy.ec2_policy" "interv-ec2-role:interv-ec2-policy" "aws iam get-role-policy --role-name interv-ec2-role --policy-name interv-ec2-policy"
        auto_import_resource "IAM Instance Profile" "aws_iam_instance_profile.ec2_profile" "interv-ec2-profile" "aws iam get-instance-profile --instance-profile-name interv-ec2-profile"
        
        # 4. RDS Resources
        echo "ğŸ—„ï¸ RDS Resources:"
        auto_import_resource "DB Subnet Group" "aws_db_subnet_group.main" "interv-db-subnet-group" "aws rds describe-db-subnet-groups --db-subnet-group-name interv-db-subnet-group"
        auto_import_resource "RDS Instance" "aws_db_instance.main" "interv-db" "aws rds describe-db-instances --db-instance-identifier interv-db"
        
        # 5. Load Balancer Resources
        echo "âš–ï¸ Load Balancer Resources:"
        ALB_ARN=$(aws elbv2 describe-load-balancers --names interv-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "None")
        if [ "$ALB_ARN" != "None" ] && [ "$ALB_ARN" != "null" ]; then
            auto_import_resource "Application Load Balancer" "aws_lb.main" "$ALB_ARN" "aws elbv2 describe-load-balancers --load-balancer-arns $ALB_ARN"
            
            # ALB Listener
            LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query 'Listeners[0].ListenerArn' --output text 2>/dev/null || echo "None")
            if [ "$LISTENER_ARN" != "None" ] && [ "$LISTENER_ARN" != "null" ]; then
                auto_import_resource "ALB Listener" "aws_lb_listener.app" "$LISTENER_ARN" "aws elbv2 describe-listeners --listener-arns $LISTENER_ARN"
            fi
        fi
        
        TG_ARN=$(aws elbv2 describe-target-groups --names interv-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "None")
        if [ "$TG_ARN" != "None" ] && [ "$TG_ARN" != "null" ]; then
            auto_import_resource "Target Group" "aws_lb_target_group.app" "$TG_ARN" "aws elbv2 describe-target-groups --target-group-arns $TG_ARN"
        fi
        
        # 6. Auto Scaling Resources
        echo "ğŸ”„ Auto Scaling Resources:"
        auto_import_resource "Auto Scaling Group" "aws_autoscaling_group.app" "interv-asg" "aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names interv-asg"
        
        LT_ID=$(aws ec2 describe-launch-templates --launch-template-names interv-lt --query 'LaunchTemplates[0].LaunchTemplateId' --output text 2>/dev/null || echo "None")
        if [ "$LT_ID" != "None" ] && [ "$LT_ID" != "null" ]; then
            auto_import_resource "Launch Template" "aws_launch_template.app" "$LT_ID" "aws ec2 describe-launch-templates --launch-template-ids $LT_ID"
        fi
        
        # 7. Elastic IP Resources
        echo "ğŸŒ Elastic IP Resources:"
        EIP_IDS=$(aws ec2 describe-addresses --query 'Addresses[].AllocationId' --output text 2>/dev/null)
        if [ -n "$EIP_IDS" ]; then
            EIP_ARRAY=($EIP_IDS)
            echo "    Found ${#EIP_ARRAY[@]} EIPs"
            
            # NAT Gateway EIPs
            for i in 0 1; do
                if [ $i -lt ${#EIP_ARRAY[@]} ]; then
                    EIP_ID=${EIP_ARRAY[$i]}
                    auto_import_resource "EIP[$i]" "aws_eip.nat[$i]" "$EIP_ID" "aws ec2 describe-addresses --allocation-ids $EIP_ID"
                fi
            done
        fi
        
        # 8. Certificate Resources
        echo "ğŸ” Certificate Resources:"
        CERT_ARN=$(aws acm list-certificates --query "CertificateSummaryList[?DomainName=='interv.swote.dev'].CertificateArn" --output text 2>/dev/null || echo "None")
        if [ "$CERT_ARN" != "None" ] && [ "$CERT_ARN" != "null" ]; then
            auto_import_resource "ACM Certificate" "aws_acm_certificate.main" "$CERT_ARN" "aws acm describe-certificate --certificate-arn $CERT_ARN"
        fi
        
        # 9. Security Groups
        echo "ğŸ”’ Security Group Resources:"
        ALB_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=interv-alb-sg-*" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$ALB_SG_ID" != "None" ] && [ "$ALB_SG_ID" != "null" ]; then
            auto_import_resource "ALB Security Group" "aws_security_group.alb" "$ALB_SG_ID" "aws ec2 describe-security-groups --group-ids $ALB_SG_ID"
        fi
        
        EC2_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=interv-ec2-sg-*" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$EC2_SG_ID" != "None" ] && [ "$EC2_SG_ID" != "null" ]; then
            auto_import_resource "EC2 Security Group" "aws_security_group.ec2" "$EC2_SG_ID" "aws ec2 describe-security-groups --group-ids $EC2_SG_ID"
        fi
        
        RDS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=interv-rds-sg-*" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        if [ "$RDS_SG_ID" != "None" ] && [ "$RDS_SG_ID" != "null" ]; then
            auto_import_resource "RDS Security Group" "aws_security_group.rds" "$RDS_SG_ID" "aws ec2 describe-security-groups --group-ids $RDS_SG_ID"
        fi
        
        echo ""
        echo "âœ… Resource discovery and import completed!"
        echo ""
    
    - name: Terraform Plan and Apply
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_key_pair_name: ${{ secrets.EC2_KEY_PAIR_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_app_name: ${{ env.APPLICATION_NAME }}
        TF_VAR_domain_name: "interv.swote.dev"
      run: |
        cd infrastructure/
        
        echo "ğŸ“‹ Running terraform plan after import..."
        terraform plan -out=tfplan
        
        echo "ğŸš€ Applying infrastructure changes..."
        terraform apply tfplan
        
        echo "ğŸ“Š Saving Terraform outputs..."
        terraform output -json > terraform-outputs.json
        
        # S3 ë²„í‚· ì´ë¦„ì„ GitHub Environmentì— ì €ì¥
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        if [ -n "$S3_BUCKET" ]; then
            echo "S3_BUCKET_NAME=$S3_BUCKET" >> $GITHUB_ENV
            echo "ğŸª£ S3 Bucket: $S3_BUCKET"
        fi
    
    outputs:
      s3_bucket_name: ${{ env.S3_BUCKET_NAME }}

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: always() && !failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'corretto'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Build application
      run: |
        echo "ğŸ“¦ Building Spring Boot application..."
        
        # í”„ë¡œì íŠ¸ êµ¬ì¡°ì— ë”°ë¼ ë¹Œë“œ ë””ë ‰í† ë¦¬ ì°¾ê¸°
        if [ -d "inter-v" ]; then
          cd inter-v
          echo "Building in inter-v directory"
        elif [ -d "BE/inter-v" ]; then
          cd BE/inter-v
          echo "Building in BE/inter-v directory"
        else
          echo "âŒ Application directory not found!"
          exit 1
        fi
        
        mvn clean package -DskipTests
        
        # ë¹Œë“œ ê²°ê³¼ í™•ì¸
        JAR_FILE=$(find target -name "*.jar" | head -1)
        if [ -n "$JAR_FILE" ]; then
          echo "âœ… Build successful: $JAR_FILE"
        else
          echo "âŒ Build failed: No JAR file found"
          exit 1
        fi
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get S3 bucket name
      id: get-bucket
      run: |
        # Terraform stateì—ì„œ S3 ë²„í‚· ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
        cd infrastructure/
        terraform init
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        
        if [ -z "$S3_BUCKET" ]; then
          echo "âŒ S3 bucket name not found!"
          exit 1
        fi
        
        echo "S3_BUCKET=$S3_BUCKET" >> $GITHUB_OUTPUT
        echo "ğŸª£ Using S3 bucket: $S3_BUCKET"
    
    - name: Upload JAR to S3
      env:
        S3_BUCKET: ${{ steps.get-bucket.outputs.S3_BUCKET }}
      run: |
        echo "ğŸ“¤ Uploading application to S3..."
        
        # JAR íŒŒì¼ ì°¾ê¸°
        if [ -d "inter-v" ]; then
          JAR_PATH="inter-v/target"
        elif [ -d "BE/inter-v" ]; then
          JAR_PATH="BE/inter-v/target"
        else
          JAR_PATH="target"
        fi
        
        JAR_FILE=$(find $JAR_PATH -name "*.jar" | head -1)
        
        if [ -n "$JAR_FILE" ]; then
          # íƒ€ì„ìŠ¤íƒ¬í”„ì™€ í•¨ê»˜ ì—…ë¡œë“œ
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          
          # ë°±ì—…ìš© ì—…ë¡œë“œ
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/releases/$TIMESTAMP/$APPLICATION_NAME.jar"
          
          # ìµœì‹  ë²„ì „ ì—…ë¡œë“œ
          aws s3 cp "$JAR_FILE" "s3://$S3_BUCKET/releases/latest/$APPLICATION_NAME.jar"
          
          # ë°°í¬ ì •ë³´ ì—…ë¡œë“œ
          echo "{\"timestamp\":\"$TIMESTAMP\",\"commit\":\"$GITHUB_SHA\",\"branch\":\"$GITHUB_REF_NAME\",\"actor\":\"$GITHUB_ACTOR\"}" > deployment-info.json
          aws s3 cp deployment-info.json "s3://$S3_BUCKET/releases/latest/deployment-info.json"
          
          echo "âœ… JAR uploaded successfully: $JAR_FILE"
          echo "ğŸ“¦ Backup: s3://$S3_BUCKET/releases/$TIMESTAMP/"
          echo "ğŸ”„ Latest: s3://$S3_BUCKET/releases/latest/"
        else
          echo "âŒ JAR file not found in $JAR_PATH"
          exit 1
        fi
    
    - name: Trigger Auto Scaling Group refresh
      run: |
        echo "ğŸ”„ Triggering Auto Scaling Group refresh..."
        
        ASG_NAME="${APPLICATION_NAME}-asg"
        
        # ASG ì¡´ì¬ í™•ì¸
        if ! aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME >/dev/null 2>&1; then
          echo "âš ï¸ Auto Scaling Group not found, skipping refresh..."
          exit 0
        fi
        
        # í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ ìƒíƒœ í™•ì¸
        aws autoscaling describe-auto-scaling-groups \
          --auto-scaling-group-names $ASG_NAME \
          --query 'AutoScalingGroups[0].{Desired:DesiredCapacity,Running:Instances[?LifecycleState==`InService`]|length(@)}'
        
        # ì¸ìŠ¤í„´ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹œì‘
        REFRESH_ID=$(aws autoscaling start-instance-refresh \
          --auto-scaling-group-name $ASG_NAME \
          --preferences MinHealthyPercentage=50,InstanceWarmup=300,CheckpointPercentages=50 \
          --query 'InstanceRefreshId' --output text)
        
        echo "ğŸ”„ Instance refresh started: $REFRESH_ID"
        echo "â³ Waiting for instance refresh to complete..."
        
        # ì™„ë£Œ ëŒ€ê¸° (íƒ€ì„ì•„ì›ƒ 20ë¶„)
        timeout 1200 aws autoscaling wait instance-refresh-successful \
          --auto-scaling-group-name $ASG_NAME \
          --instance-refresh-ids $REFRESH_ID || {
          echo "âš ï¸ Instance refresh timeout, but continuing..."
        }
        
        echo "âœ… Instance refresh completed!"
    
    - name: Health check and verification
      run: |
        echo "ğŸ” Performing post-deployment health checks..."
        
        # ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ëŒ€ê¸°
        echo "â³ Waiting for application startup (60 seconds)..."
        sleep 60
        
        # Health check
        HEALTH_URL="https://interv.swote.dev/actuator/health"
        MAX_ATTEMPTS=10
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "ğŸ¥ Health check attempt $i/$MAX_ATTEMPTS..."
          
          if curl -f -s --max-time 10 "$HEALTH_URL" > /dev/null; then
            echo "âœ… Application is healthy!"
            
            # ìƒì„¸ ìƒíƒœ í™•ì¸
            echo "ğŸ“Š Application status:"
            curl -s --max-time 10 "$HEALTH_URL" | jq . || curl -s --max-time 10 "$HEALTH_URL"
            
            break
          else
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "âŒ Health check failed after $MAX_ATTEMPTS attempts"
              echo "ğŸ” Checking ALB target health..."
              
              # ALB íƒ€ê²Ÿ ê·¸ë£¹ ìƒíƒœ í™•ì¸
              TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
                --names "${APPLICATION_NAME}-tg" \
                --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "None")
              
              if [ "$TARGET_GROUP_ARN" != "None" ]; then
                aws elbv2 describe-target-health \
                  --target-group-arn $TARGET_GROUP_ARN
              fi
              
              exit 1
            fi
            
            echo "â³ Waiting 30 seconds before retry..."
            sleep 30
          fi
        done
        
        echo ""
        echo "ğŸ‰ Deployment completed successfully!"
        echo "ğŸŒ Application URL: https://interv.swote.dev"
        echo "ğŸ¥ Health Check: https://interv.swote.dev/actuator/health"
        echo "ğŸ“Š Monitoring: AWS CloudWatch Console"